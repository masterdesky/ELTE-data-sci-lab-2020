In this presentation I would like to speak about two topics. First the basic usage of graphics in R, then the usage of vectors in R. First of all, I'm not sure, how long this presentation will be. I really tried to detail every aspect of both topics, but they're discussing such elementary concepts, which I simply can't tell in an interesting manner to an audience with heavy programming background and knowledge, especially in Python (very similar to R) and other languages. Everyone know, what plotting is or arrays and loops and other elementary things like these mean, so I'll try to focus on more like the implementation of these concepts in R, and their way of usage. Instead of detailing that - I don't know... what variables and the `for` loop mean.


# GRAPHICS IN R

Okay, let's start. The first chapter that I was ought to work on was the section 1.5 in the DAGUR book. In this chapter - as I mentioned - the basics of the graphical capabilities of R are being discussed. In the whole DAGUR book there are - as far as I know - only 3 main different graphical libraries are mentioned. First the simplest one, simply called as `graphics`, then the `lattice` and `ggplot2` packages. In this chapter, mostly the package called `graphics` are detailed, and a brief outlook at `lattice` is also given at the end of the chapter. So for now, I'll only speak about these two.

So, first. The library `graphics` are loaded at startup by default in R and contains some basic routines called eg. `plot()`, `points()`, `lines()`, `text()`, `mtext()` and `axis()`. In the first half of the presentation I would like to go through all of these.

So I've tried to make some "nicer" plots, using the graphics package only to showcase the usage and functionality of these basic function. Well, I didn't had any good and original idea for what interesting dataset to visualize on a simple scatter plot, so I just plotted the simplest 1D and 2D Brownian motion. Creating a figure like this, wasn't completely straightforward at first. Also the `graphics` package has many limitations (eg. the size and aspect of the figure can not intuitively changed, the arrangement of a lot of elements are not automated, etc.)

Okay, but let's go through the elements, which the plot was built of. First - as I said - generate a 1D Brownian motion dataset for a 100 steps, everyone's familiar with this already. All the following lines in this cell belong to the plot. The steps of creating a figure in R is very similar to the steps in Python. First you need to initialize a figure object and only after that, you can add data to the image and format its appearance and do whatever you want. In the R package `graphics` the initialization happens by invoking the `plot()` function with some input data (here, x and y). It not just creates the figure, but also plots the xy data on a scatter plot. If we want to use the dedicated function called `points()` to create a scatter plot, then we need to turn off the rendering of points by `plot()` (by passing `type='n'`). Also we need to prevent it from labeling the axes, if we want to override the axis labels (by passing `ann=FALSE`). Prior to that, I called `par()`, the function, which sets graphical/visual parameters for the plot (or more like it actually just queries them until the next initialization of a new figure). Whatever. It is used to define "global" parameters for the figure, next initialized and plotted. Okay. Calling the `box()` function after `plot()` configures literally the "box" directly around the plotted data on the figure.
In the next step(s) I plotted the generated r(t) scatter points, and draw grey line collections between consecutive scatter points. I've passed the `bg=grey` argument to the `points()` function, which sets the facecolor of scatter points. Also used the `pch` argument (which probably stands for `point/plot character`, or something like that). It sets the character, used for the rendering of scatter points. This can be set by passing an integer to `pch`, which probably functions as an index, and returns the corresponding char from the list of usable ASCII(? I'm not sure, whether they're ASCII exclusively or not) characters.
To the `lines()` function I passed the `col` argument, which sets the color of the lines between the points given by the input X and Y coordinates.

After that, I used the A-B line (`abline()`) function, which draws an arbitrary line from side to side over the graph. It has 4 important arguments, `a`, `b`, `h` and `v`. `a` denotes the intercept of the line, while `b` denotes its slope (So in the equation $y = mx + b$, `a` represents $b$, and `b` represents $m$, pretty much contra intuitive, but okay.) I drew two lines to visualize both the mean and the standard deviation of this random Brownian motion with finite steps. Also I created a y=0 baseline to represent the X axis.

Next, I've used the `text()` function, to write "mean" and "std" over an XY coordinate in the plot. X and Y sets the actual coordinate value on the graph to place the text box at, while the `pos` parameter decides, in which direction the text should be placed relative to the choosen XY position. The values 1, 2, 3 and 4 can be passed to this `pos` argument, where each number correspond to one of the 4 cardinal directions. Here, `pos=3` means place the text to north and `pos=1` means place the text to south, relative to the chosen XY coordinate.

The `axis()` function controls the visuals of the ticks, tick labels and the coordinate axis. The `col`, `col.ticks` and `col.axis` parameters controls the color of the tick labels, the ticks and the coordinate axes respectively. The cex.* is used to control the size of different elements on a figure. Here `cex.axis=1.5` means, the the tick labels are 1.5 times bigger, than they're default. Yes, you don't set sizes explicitly, but only relatively to the default values.

The `grid()` function simply draws a grid in the chosen style to the graph.

And finally the `title()` function is used to set the title, and axis labels on the graph. It can control the color and style of text in the title, and labels, as well their sizes and much more.

=========

Okay, so I did the same for the 2D Brownian motion too. The only difference, that I draw a red line to mark the displacement of the wandering particle. I think it was okay for an example figure. I also tried to plot something nice using default R graphics to showcase its capabilities. There is an - I think - interesting visualization method, called domain coloring, which is used to visualize, normally 4D complex functions in 2D. Since I've played with it in Python in the last week, I tried to implement the very basics of it in R too.


# VECTORS IN R

In vector arithmetics, R likes to opearte on vectors of the same length. If two vectors of different length are encounter each other in an operatorn, the smaller vector gets so-called "recycled". The smaller vector is repeated from the beginning until its length matches the longer vector. If the smaller length is not a multiplier of the larger one, so the shorter vector can be just partially repeated
